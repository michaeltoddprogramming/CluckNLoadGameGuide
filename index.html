<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cluck N Load - Official Game Guide</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Load Inter from Google for body, but use local TTF for Lilita headings -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">

    <!-- Local Lilita One (use the bundled TTF) -->
    <style>
        @font-face {
            font-family: 'Lilita One';
            src: url('./LilitaOne-Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root{
            --stroke-color: #2b1e14; /* dark outline color similar to your Unity art */
            --stroke-width: 1.6px;    /* heading stroke (subtle) */
            --body-stroke-width: 0px; /* body text no stroke for readability */
        }

        body {
            /* keep Inter for body copy for readability; Lilita One is used for headings */
            font-family: 'Inter', 'Lilita One', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #87CEEB 0%, #2C5F2D 100%);
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.2);
        }

        /* Header Styles */
        header {
            background: linear-gradient(90deg, #87CEEB 0%, #87CEEB 50%, #1a1a2e 50%, #1a1a2e 100%);
            color: white;
            padding: 60px 20px 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .logo-section {
            margin-bottom: 20px;
        }

        h1 {
            font-family: 'Lilita One', 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 3.5em;
            margin-bottom: 5px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.4);
            color: #ff6b35;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        /* Headline outline: use multiple small text-shadow offsets (no -webkit-text-stroke)
           This produces a consistent outline in all browsers and printing engines without
           the heavy, blocky artifacts caused when combining stroke + large shadows. */
        h1, h2, h3, h4, .unit-name, .unit-icon, .phase-icon, .tagline, .export-btn, .model-viewer h2 {
            /* eight-direction subtle outline */
            text-shadow:
                -2px 0 0 var(--stroke-color),
                2px 0 0 var(--stroke-color),
                0 -2px 0 var(--stroke-color),
                0 2px 0 var(--stroke-color),
                -1.4px -1.4px 0 var(--stroke-color),
                1.4px -1.4px 0 var(--stroke-color),
                -1.4px 1.4px 0 var(--stroke-color),
                1.4px 1.4px 0 var(--stroke-color),
                0 2px 6px rgba(0,0,0,0.18);
        }

        /* Subtle outline for body copy so the decorative font keeps readability */
        p, li, table td, table th, .intro-box, .tips-box, .warning-box, .season-track, .unit-card {
            /* no stroke on body copy; keep a very subtle shadow for depth, not outline */
            -webkit-text-stroke: 0px transparent;
            text-shadow: 0.6px 0.6px 0 rgba(43,30,20,0.12);
        }

        .tagline {
            font-size: 1.3em;
            font-style: italic;
            background: white;
            color: #ff6b35;
            padding: 8px 20px;
            display: inline-block;
            border-radius: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        /* Export PDF button (header) */
        .export-btn {
            position: absolute;
            right: 18px;
            top: 18px;
            background: #ff6b35;
            color: white;
            border: none;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 700;
            box-shadow: 0 6px 14px rgba(0,0,0,0.15);
        }
        .export-btn:hover{ transform: translateY(-2px); }

        /* Day/Night Icons */
        .cycle-indicator {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 20px;
            font-size: 3em;
        }

        .day-icon::before {
            content: '‚òÄÔ∏è';
        }

        .night-icon::before {
            content: 'üåô';
        }

        /* 3D Viewer Section */
        .model-viewer {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            padding: 30px 20px;
            text-align: center;
            position: relative;
        }

        .model-viewer h2 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        #canvas-container {
            width: 100%;
            height: 400px;
            background: radial-gradient(circle, #3d5a6b 0%, #2c3e50 100%);
            border-radius: 10px;
            position: relative;
            border: 3px solid #ff6b35;
        }

        /* make canvas show pointer feedback */
        #canvas-container canvas { cursor: grab; touch-action: none; }

        .viewer-hint {
            color: #ecf0f1;
            font-size: 0.9em;
            margin-top: 10px;
            opacity: 0.8;
        }

        /* Content Sections */
        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
            page-break-inside: avoid;
        }

        h2 {
            color: #ff6b35;
            font-size: 2em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 3px solid #ff6b35;
        }

        h3 {
            color: #2c5f2d;
            font-size: 1.5em;
            margin: 25px 0 12px 0;
        }

        h4 {
            color: #555;
            font-size: 1.2em;
            margin: 15px 0 8px 0;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .intro-box {
            background: linear-gradient(135deg, #fff9e6 0%, #ffe8b3 100%);
            padding: 30px;
            border-radius: 12px;
            border-left: 6px solid #ff6b35;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Game Loop Visual */
        .game-loop {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 25px 0;
        }

        .loop-phase {
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .day-phase {
            background: linear-gradient(135deg, #87CEEB 0%, #B8E6F0 100%);
            border: 3px solid #FFD700;
        }

        .night-phase {
            background: linear-gradient(135deg, #1a1a2e 0%, #2d3561 100%);
            color: white;
            border: 3px solid #8B7355;
        }

        .phase-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        /* Army Units Grid */
        .units-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .unit-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            text-align: center;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .unit-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .unit-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .unit-name {
            font-weight: bold;
            color: #2c5f2d;
            margin-bottom: 8px;
        }

        /* Enemy Units */
        .enemy-card {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            border: 2px solid #c62828;
        }

        .enemy-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        /* Resources Table */
        .resources-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .resources-table th,
        .resources-table td {
            padding: 15px;
            text-align: left;
            border: 1px solid #ddd;
        }

        .resources-table th {
            background: #2c5f2d;
            color: white;
            font-weight: bold;
        }

        .resources-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .resource-icon {
            font-size: 1.5em;
            margin-right: 8px;
        }

        /* Strategy Tips */
        .tips-box {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 25px;
            border-radius: 10px;
            border-left: 6px solid #1976d2;
            margin: 20px 0;
        }

        .tips-box h4 {
            color: #1976d2;
            margin-bottom: 15px;
        }

        .warning-box {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            padding: 20px;
            border-radius: 8px;
            border-left: 6px solid #f57c00;
            margin: 20px 0;
        }

        .warning-box h4 {
            color: #f57c00;
            margin-bottom: 10px;
        }

        ul {
            margin-left: 25px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 10px;
        }

        strong {
            color: #2c5f2d;
        }

        /* Season Progression */
        .season-track {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #ddd;
        }

        .season-days {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
        }

        .day-marker {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 8px;
            border: 2px solid #2c5f2d;
            min-width: 60px;
        }

        /* Footer */
        footer {
            background: linear-gradient(90deg, #2c5f2d 0%, #1a1a2e 100%);
            color: white;
            text-align: center;
            padding: 30px 20px;
        }

        /* Print Styles */
        @media print {
            /* Page & body - reduce the top margin a bit so browser print headers don't push content down too far */
            @page { size: A4 portrait; margin: 6mm 10mm 12mm 10mm; }
            html, body { height: auto; }
            body {
                background: white !important;
                color: #000;
                /* Prefer the loaded webfont and fall back to common sans-serif fonts for reliable printing */
                font-family: 'Inter', Arial, Helvetica, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
                font-size: 12pt;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            /* Force sans-serif for body/content while preserving decorative headline font */
            body, .container, .content, header, footer, .intro-box, .tips-box, .warning-box, .season-track, .unit-card, .enemy-card, table, p, li {
                font-family: 'Inter', Arial, Helvetica, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
            }

            /* Use Lilita One for large headings to match Unity TextMeshPro look */
            h1, h2, h3 { font-family: 'Lilita One', 'Inter', Arial, Helvetica, sans-serif !important; }

            /* Container becomes full-bleed page content and uses more vertical space */
            .container {
                box-shadow: none;
                max-width: 100%;
                border-radius: 0;
                margin: 0;
                padding: 0 6mm 6mm 6mm;
            }

            /* Hide interactive or decorative elements */
            .model-viewer, .viewer-hint, .cycle-indicator, #canvas-container, .model-controls { display: none !important; }
            .unit-card:hover, .loop-phase:hover { transform: none; box-shadow: none; }

            /* Header simplified for print and reduced height to avoid big top whitespace */
            header {
                background: none !important;
                /* keep header color inherited so headings can retain their accent colors in print */
                color: inherit !important;
                padding: 8px 0 !important;
                text-align: left;
                margin-bottom: 6mm;
            }
            header .logo-section { display:flex; flex-direction:column; gap:2px }
            /* Keep heading colors when printing; many browsers/print drivers aggressively flatten colors to black
               unless print-color-adjust is requested. Request exact color reproduction for headings. */
            h1 { color: #ff6b35; font-size: 22px; letter-spacing: 1px; margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            .tagline { background: none; color: #ff6b35; padding: 0; display: inline; box-shadow:none; font-style:italic }

            /* Make headings crisp and sized for print; preserve on-brand colors */
            h2 { color: #ff6b35; font-size: 16pt; margin-top: 6mm; -webkit-print-color-adjust: exact; print-color-adjust: exact; border-bottom-color: #ff6b35 !important; }
            h3 { color: #2c5f2d; font-size: 13pt; -webkit-print-color-adjust: exact; print-color-adjust: exact; }

            /* Ensure boxes print well even if backgrounds are disabled in the print dialog */
            .intro-box, .tips-box, .warning-box, .season-track, .resources-table, .unit-card, .enemy-card {
                background: none !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                box-shadow: none;
                border: 1px solid #ddd;
                padding: 12px;
            }

            .visual-placeholder { border: 1px solid #ccc; background: #fff; color: #000; height: auto }

            /* Avoid breaking cards/table rows across pages */
            .section, .unit-card, .enemy-card, .resources-table tr { page-break-inside: avoid; }

            /* Force helpful page breaks to keep sections tidy */
            .break-after { page-break-after: always; }

            /* Hide any controls or interactive affordances */
            .btn, .print-only-hide, .export-btn { display: none !important; }

            /* Images and tables fit page width */
            img, table { max-width: 100% !important; }
        }

        /* Styles applied just before exporting to PDF to compact layout on-screen before print() */
        .print-ready header { padding: 6px 0 !important; }
        .print-ready .content { padding: 6mm 6mm 12mm 6mm; }
        /* Responsive layout tweaks */
        @media (max-width: 900px) {
            .container { margin: 0 12px; }
            .content { padding: 24px; }
            #canvas-container { height: 480px; }
            .game-loop { grid-template-columns: 1fr; }
            .units-grid { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
        }

        @media (max-width: 600px) {
            header { padding: 32px 12px 20px; }
            h1 { font-size: 2em; letter-spacing: 1px; }
            .export-btn { right: 10px; top: 10px; padding: 8px 10px; }
            .model-controls { flex-direction: column; gap: 8px; }
            #canvas-container { height: 340px; border-width: 2px; }
            .content { padding: 16px; }
            .viewer-hint { font-size: 0.85em; }
            .unit-card { padding: 14px; }
            .tagline { padding: 6px 12px; font-size: 1em; }
            /* increase touch target sizes for mobile */
            button, input[type="file"] { touch-action: manipulation; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo-section">
                <h1>CLUCK N' LOAD</h1>
                <p class="tagline">The Farm Defends Itself</p>
            </div>
            <div class="cycle-indicator">
                <span class="day-icon"></span>
                <span class="night-icon"></span>
            </div>
            <button class="export-btn" id="export-pdf">Export PDF</button>
        </header>

        <!-- 3D Model Viewer -->
        <div class="model-viewer">
            <h2>üêî Your Brave Defenders</h2>
            <div id="canvas-container"></div>
            <div class="model-controls" style="margin-top:12px;display:flex;gap:12px;align-items:center;justify-content:center;">
                <label style="display:flex;gap:8px;align-items:center;color:#fff;">
                    <input id="auto-rotate" type="checkbox"> Auto-rotate
                </label>
                <label style="color:#fff;">
                    Load model (.glb/.gltf):
                    <input id="model-file" type="file" accept=".glb,.gltf" style="display:inline-block;margin-left:6px">
                </label>
                <button id="clear-model" style="background:#ff6b35;color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer">Clear Model</button>
                <div id="model-info" style="color:#fff;font-weight:700;margin-left:6px">Default: built-in chicken</div>
            </div>
            <p class="viewer-hint">Interactive 3D Preview ‚Ä¢ Drag to rotate ‚Ä¢ Scroll to zoom</p>
        </div>

        <div class="content">
            <!-- Introduction -->
            <section class="section">
                <div class="intro-box">
                    <h2>üåæ Welcome to Cluck N' Load</h2>
                    <p><strong>By day, you're a farmer. By night, you're a commander.</strong></p>
                    <p>In Cluck N' Load, you must balance the peaceful life of farming with the chaos of defending your homestead. Plant crops, raise animals, and build your farm during the sunny hours. But when darkness falls, your peaceful livestock transform into an elite defense force ready to protect everything you've built from waves of hungry predators.</p>
                    <p>Combine the relaxing gameplay of farming simulators with the strategic intensity of tower defense. Will your farm survive the night?</p>
                </div>
            </section>

            <!-- Core Game Loop -->
            <section class="section">
                <h2>‚öôÔ∏è The Day/Night Cycle</h2>
                <p>Cluck N' Load operates on a unique day/night cycle that defines every aspect of gameplay. Master both phases to ensure your farm's survival and prosperity.</p>
                
                <div class="game-loop">
                    <div class="loop-phase day-phase">
                        <div class="phase-icon">‚òÄÔ∏è</div>
                        <h3 style="color: #2c5f2d;">DAYTIME</h3>
                        <p style="color: #333;"><strong>Farm & Prepare</strong></p>
                        <ul style="text-align: left; color: #333;">
                            <li>Plant and harvest crops</li>
                            <li>Feed your animals</li>
                            <li>Recruit animals to your army</li>
                            <li>Place defensive flags</li>
                            <li>Build and upgrade structures</li>
                            <li>Collect resources and money</li>
                        </ul>
                    </div>
                    
                    <div class="loop-phase night-phase">
                        <div class="phase-icon">üåô</div>
                        <h3>NIGHTTIME</h3>
                        <p><strong>Defend & Survive</strong></p>
                        <ul style="text-align: left;">
                            <li>Animals move to flag positions</li>
                            <li>Enemies attack in waves</li>
                            <li>Protect your crops and buildings</li>
                            <li>Survive until dawn</li>
                            <li>Earn rewards for successful defense</li>
                            <li>Prepare for harder nights ahead</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Farming System -->
            <section class="section">
                <h2>üå± Farming & Resources</h2>
                <p>Your farm is the economic engine that powers your defenses. During the day, focus on growing crops and managing your livestock to generate the money needed for expansion and army recruitment.</p>

                <h3>Crops</h3>
                <table class="resources-table">
                    <thead>
                        <tr>
                            <th>Crop</th>
                            <th>Purpose</th>
                            <th>Growth Time</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="resource-icon">üåæ</span>Wheat</td>
                            <td>Primary animal feed - feeds chickens, sheep, goats</td>
                            <td>Fast growing</td>
                        </tr>
                        <tr>
                            <td><span class="resource-icon">ü•ï</span>Carrots</td>
                            <td>Premium feed - feeds pigs and cows for better yields</td>
                            <td>Medium growing</td>
                        </tr>
                        <tr>
                            <td><span class="resource-icon">üåª</span>Sunflowers</td>
                            <td>Cash crop - sells for high profit to fund upgrades</td>
                            <td>Slow growing</td>
                        </tr>
                    </tbody>
                </table>

                <h3>The Economic Loop</h3>
                <p><strong>Plant Crops ‚Üí Feed Animals ‚Üí Animals Produce Resources ‚Üí Sell for Money ‚Üí Buy More Animals/Upgrades ‚Üí Repeat</strong></p>
                <p>Well-fed animals are happy animals, and happy animals make better soldiers! Keep your livestock fed to maximize their effectiveness in combat and their production during the day.</p>
            </section>

            <!-- Army System -->
            <section class="section">
                <h2>üõ°Ô∏è Your Army: The Defender Units</h2>
                <p>Any animal on your farm can be recruited into your defensive army. Once recruited, these brave creatures will defend their home when night falls. Each animal type has unique strengths and combat roles.</p>

                <h3>Defender Units</h3>
                <div class="units-grid">
                    <div class="unit-card">
                        <div class="unit-icon">üêî</div>
                        <div class="unit-name">Chicken</div>
                        <p><strong>Role:</strong> Fast Attacker</p>
                        <p>Quick, agile units that swarm enemies. Low health but high speed. Best in groups.</p>
                    </div>
                    
                    <div class="unit-card">
                        <div class="unit-icon">üêÑ</div>
                        <div class="unit-name">Cow</div>
                        <p><strong>Role:</strong> Tank</p>
                        <p>Heavy, durable defenders with high health. Slow but can take massive damage.</p>
                    </div>
                    
                    <div class="unit-card">
                        <div class="unit-icon">üêê</div>
                        <div class="unit-name">Goat</div>
                        <p><strong>Role:</strong> Balanced Fighter</p>
                        <p>Well-rounded units with decent speed and strength. Great for frontline defense.</p>
                    </div>
                    
                    <div class="unit-card">
                        <div class="unit-icon">üêë</div>
                        <div class="unit-name">Sheep</div>
                        <p><strong>Role:</strong> Support</p>
                        <p>Provide area buffs to nearby units. Keeps your defense line strong.</p>
                    </div>
                    
                    <div class="unit-card">
                        <div class="unit-icon">üê∑</div>
                        <div class="unit-name">Pig</div>
                        <p><strong>Role:</strong> Heavy Hitter</p>
                        <p>High damage output with moderate health. Excellent against tough enemies.</p>
                    </div>
                </div>

                <h3>Flag Defense System</h3>
                <p>During the day, place flags at strategic locations around your farm. When night falls, your recruited animals will automatically move to their assigned flag positions and defend that area. Plan your flag placement carefully:</p>
                <ul>
                    <li><strong>Protect Key Assets:</strong> Place flags near valuable crops and buildings</li>
                    <li><strong>Create Defensive Lines:</strong> Position flags to form barriers against enemy paths</li>
                    <li><strong>Mix Unit Types:</strong> Assign different animals to the same flag for balanced defense</li>
                    <li><strong>Watch Enemy Patterns:</strong> Adjust flag positions based on where enemies attack</li>
                </ul>
            </section>

            <!-- Enemy System -->
            <section class="section">
                <h2>üëπ The Threats: Enemy Units</h2>
                <p>As night falls, waves of predators emerge from the wilderness with one goal: destroy your farm and feast on your livestock. Each season introduces new, more dangerous threats.</p>

                <h3>Enemy Types</h3>
                <div class="units-grid">
                    <div class="unit-card enemy-card">
                        <div class="enemy-icon">üê∫</div>
                        <div class="unit-name" style="color: #c62828;">Wolf</div>
                        <p><strong>Fast & Aggressive</strong></p>
                        <p>Quick attackers that target chickens and sheep. Hunt in packs.</p>
                    </div>
                    
                    <div class="unit-card enemy-card">
                        <div class="enemy-icon">ü¶ù</div>
                        <div class="unit-name" style="color: #c62828;">Raccoon</div>
                        <p><strong>Sneaky Thieves</strong></p>
                        <p>Fast movement, targets crops and resources. Hard to catch.</p>
                    </div>
                    
                    <div class="unit-card enemy-card">
                        <div class="enemy-icon">üêó</div>
                        <div class="unit-name" style="color: #c62828;">Boar</div>
                        <p><strong>Armored Bruiser</strong></p>
                        <p>High health, charges through defenses. Needs focused fire to stop.</p>
                    </div>
                    
                    <div class="unit-card enemy-card">
                        <div class="enemy-icon">üêª</div>
                        <div class="unit-name" style="color: #c62828;">Bear</div>
                        <p><strong>Ultimate Threat</strong></p>
                        <p>Massive health and damage. Destroys everything in its path. All hands on deck!</p>
                    </div>
                </div>

                <div class="warning-box">
                    <h4>‚ö†Ô∏è Season Progression</h4>
                    <p><strong>Every 5 days marks a new season, and with each season comes a new enemy type!</strong></p>
                    <p>Nights also get progressively harder within each season, with more enemies, stronger variants, and larger waves. Don't get complacent‚Äîalways be preparing for the next threat.</p>
                </div>
            </section>

            <!-- Progression System -->
            <section class="section">
                <h2>üìà Progression & Seasons</h2>
                <p>Cluck N' Load features a seasonal progression system that keeps you on your toes. Each season lasts 5 days (5 day/night cycles) and introduces new challenges.</p>

                <div class="season-track">
                    <h3 style="text-align: center; color: #2c5f2d;">Season Structure</h3>
                    <div class="season-days">
                        <div class="day-marker">
                            <strong>Day 1</strong><br>
                            <small>New Season</small>
                        </div>
                        <div class="day-marker">
                            <strong>Day 2-4</strong><br>
                            <small>Difficulty ‚Üë</small>
                        </div>
                        <div class="day-marker">
                            <strong>Day 5</strong><br>
                            <small>Boss Wave</small>
                        </div>
                        <div class="day-marker">
                            <strong>Day 6</strong><br>
                            <small>Next Season</small>
                        </div>
                    </div>
                </div>

                <h3>What Changes Each Season?</h3>
                <ul>
                    <li><strong>New Enemy Types:</strong> A fresh threat is introduced every 5 days</li>
                    <li><strong>Increased Difficulty:</strong> Enemies become stronger and more numerous</li>
                    <li><strong>Day 5 Boss Fight:</strong> The final night of each season features an intense wave with multiple enemy types</li>
                    <li><strong>Better Rewards:</strong> Higher seasons offer greater rewards and unlock new upgrades</li>
                </ul>
            </section>

            <!-- Strategy Guide -->
            <section class="section">
                <h2>üéØ Pro Strategies & Tips</h2>
                
                <div class="tips-box">
                    <h4>üí° Early Game Strategy (Days 1-5)</h4>
                    <ul>
                        <li><strong>Focus on Wheat:</strong> It grows fast and keeps your starting animals fed</li>
                        <li><strong>Get 3-4 Chickens First:</strong> They're cheap, fast, and perfect for early wolf threats</li>
                        <li><strong>Place Flags at Entrances:</strong> Identify where enemies spawn and defend those chokepoints</li>
                        <li><strong>Don't Overexpand:</strong> Keep your farm compact so defenses cover more area</li>
                        <li><strong>Save for a Cow:</strong> Get one tank unit by Day 3 for added durability</li>
                    </ul>
                </div>

                <div class="tips-box">
                    <h4>üí° Mid Game Strategy (Days 6-15)</h4>
                    <ul>
                        <li><strong>Diversify Your Crops:</strong> Start planting carrots for better animal yields</li>
                        <li><strong>Build a Balanced Army:</strong> Mix chickens (speed), cows (tank), and pigs (damage)</li>
                        <li><strong>Multiple Flag Positions:</strong> Don't put all units at one flag‚Äîspread your defense</li>
                        <li><strong>Farm Sunflowers:</strong> You need the cash influx for rapid expansion</li>
                        <li><strong>Prepare for Boars:</strong> These armored enemies need focused firepower</li>
                    </ul>
                </div>

                <div class="tips-box">
                    <h4>üí° Late Game Strategy (Day 16+)</h4>
                    <ul>
                        <li><strong>Bear Defense Formation:</strong> When bears appear, concentrate your strongest units at one flag</li>
                        <li><strong>Mass Production:</strong> You need money fast‚Äîmaximize sunflower production</li>
                        <li><strong>Army Composition:</strong> 2 Cows, 3 Pigs, 4 Goats, 2 Sheep is a strong late-game mix</li>
                        <li><strong>Layered Defense:</strong> Create multiple defensive lines with flags</li>
                        <li><strong>Sacrifice Outer Fields:</strong> Better to lose some crops than your core buildings</li>
                    </ul>
                </div>

                <h3>Common Mistakes to Avoid</h3>
                <ul>
                    <li>‚ùå <strong>Forgetting to Feed Animals:</strong> Starving animals are weak defenders</li>
                    <li>‚ùå <strong>Too Many Chickens:</strong> They die easily to AOE attacks‚Äîdiversify!</li>
                    <li>‚ùå <strong>Ignoring Flag Placement:</strong> Bad positioning means enemies slip through</li>
                    <li>‚ùå <strong>Hoarding Money:</strong> Invest in animals and upgrades‚Äîcash doesn't defend you</li>
                    <li>‚ùå <strong>Expanding Too Fast:</strong> Large farms are harder to defend</li>
                </ul>
            </section>

            <!-- Unique Selling Points -->
            <section class="section">
                <h2>‚ú® What Makes Cluck N' Load Special</h2>
                <p>Cluck N' Load isn't just another farming game or tower defense clone‚Äîit's a unique blend that creates an entirely fresh gameplay experience:</p>
                
                <ul>
                    <li><strong>üîÑ Dual Gameplay Loop:</strong> Seamlessly transitions between relaxing farming and intense strategy</li>
                    <li><strong>üêî Your Animals, Your Army:</strong> Every creature you raise becomes part of your defense force</li>
                    <li><strong>üåç Dynamic Day/Night Cycle:</strong> Every decision during the day impacts your survival at night</li>
                    <li><strong>üìä Economic Strategy:</strong> Balance farming profits with military investment</li>
                    <li><strong>üé® Charming Art Style:</strong> Beautiful split-screen aesthetic showing day and night simultaneously</li>
                    <li><strong>‚öîÔ∏è Progressive Difficulty:</strong> New enemies every season keep gameplay fresh and challenging</li>
                    <li><strong>üö© Strategic Flag System:</strong> Tactical positioning determines success or failure</li>
                    <li><strong>üå± Resource Management:</strong> Every crop matters‚Äîfeed your army or sell for cash?</li>
                </ul>

                <p>It's <strong>Hay Day</strong> meets <strong>Clash of Clans</strong> meets <strong>Plants vs Zombies</strong>‚Äîbut with its own unique identity. Will you become the ultimate farmer-commander and defend your homestead against the wilderness?</p>
            </section>
        </div>

        <footer>
            <p><strong>CLUCK N' LOAD</strong></p>
            <p>The Farm Defends Itself</p>
            <p style="margin-top: 20px; font-size: 0.9em;">&copy; 2025 Cluck N' Load Game Guide ‚Ä¢ All Rights Reserved</p>
        </footer>
    </div>

    <script>
        // Three.js 3D Scene Setup
        const scene = new THREE.Scene();

        const container = document.getElementById('canvas-container');

        // Camera: use container aspect ratio and position it so the model is visible
        const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);
        camera.lookAt(0, 0.8, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    // Clamp pixel ratio for mobile to avoid excessive GPU work on high-DPI devices.
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setClearColor(0x2c3e50);
        renderer.domElement.style.width = '100%';
        renderer.domElement.style.height = '100%';
        container.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Ground plane for visual reference
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x2d6a3a, roughness: 0.8, metalness: 0 });
        const groundGeo = new THREE.PlaneGeometry(40, 40);
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.9;
        scene.add(ground);

    // Orbit controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.screenSpacePanning = false;
    controls.minDistance = 1.5;
    controls.maxDistance = 20;
    controls.maxPolarAngle = Math.PI / 2.1; // prevent going below ground

    // Track currently loaded model
    let currentModel = null;

    // Create a simple farm animal (chicken) using basic geometries as default
    const chickenGroup = new THREE.Group();

        // Body
        const bodyGeometry = new THREE.SphereGeometry(0.8, 32, 32);
        const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.scale.set(1, 1.2, 1);
        chickenGroup.add(body);

        // Head
        const headGeometry = new THREE.SphereGeometry(0.45, 32, 32);
        const head = new THREE.Mesh(headGeometry, bodyMaterial);
        head.position.set(0, 1, 0.4);
        chickenGroup.add(head);

        // Beak
        const beakGeometry = new THREE.ConeGeometry(0.15, 0.35, 16);
        const beakMaterial = new THREE.MeshPhongMaterial({ color: 0xffa500 });
        const beak = new THREE.Mesh(beakGeometry, beakMaterial);
        beak.rotation.x = Math.PI / 2;
        beak.position.set(0, 1, 0.75);
        chickenGroup.add(beak);

        // Comb
        const combGeometry = new THREE.SphereGeometry(0.18, 16, 16);
        const combMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const comb = new THREE.Mesh(combGeometry, combMaterial);
        comb.position.set(0, 1.2, 0);
        chickenGroup.add(comb);

        chickenGroup.position.set(0, 0, 0);
        scene.add(chickenGroup);
        currentModel = chickenGroup;

        // GLTF loader for user models
        const gltfLoader = new THREE.GLTFLoader();

        // Helpers: remove current model
        function clearCurrentModel() {
            if (!currentModel) return;
            scene.remove(currentModel);
            // dispose geometries/materials if possible
            currentModel.traverse && currentModel.traverse(function (node) {
                if (node.geometry) node.geometry.dispose && node.geometry.dispose();
                if (node.material) {
                    if (Array.isArray(node.material)) node.material.forEach(m => m.dispose && m.dispose());
                    else node.material.dispose && node.material.dispose();
                }
            });
            currentModel = null;
            document.getElementById('model-info').textContent = 'None';
        }

        // Center and scale model to fit in view
        function fitModelToView(object, desiredSize = 2.5) {
            const box = new THREE.Box3().setFromObject(object);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = maxDim > 0 ? (desiredSize / maxDim) : 1;
            object.scale.setScalar(scale);
            // center
            const center = box.getCenter(new THREE.Vector3());
            object.position.sub(center.multiplyScalar(scale));
        }

        // Load model from file input (ArrayBuffer)
        function loadModelFromFile(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const arrayBuffer = e.target.result;
                try {
                    gltfLoader.parse(arrayBuffer, '', function (gltf) {
                        clearCurrentModel();
                        const model = gltf.scene || gltf.scenes[0];
                        fitModelToView(model);
                        scene.add(model);
                        currentModel = model;
                            document.getElementById('model-info').textContent = file.name;
                            tryApplyTexturesFor(file.name);
                    }, function (err) {
                        console.error('GLTF parse error', err);
                        alert('Failed to parse model file. See console for details.');
                    });
                } catch (err) {
                    console.error(err);
                    alert('Failed to load model.');
                }
            };
            // read as array buffer
            reader.readAsArrayBuffer(file);
        }

        // Wire UI controls
        const fileInput = document.getElementById('model-file');
        const clearBtn = document.getElementById('clear-model');
        const autoRotateCheckbox = document.getElementById('auto-rotate');

        fileInput.addEventListener('change', function (evt) {
            const f = evt.target.files && evt.target.files[0];
            if (!f) return;
            loadModelFromFile(f);
        });

        clearBtn.addEventListener('click', function () {
            clearCurrentModel();
            // restore default chicken
            scene.add(chickenGroup);
            currentModel = chickenGroup;
            document.getElementById('model-info').textContent = 'Default: built-in chicken';
        });

        // Handle resize so canvas always fits its container
        function onResize() {
            const w = container.clientWidth || 800;
            const h = container.clientHeight || 400;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
            // re-apply a safe pixel ratio on resize (in case devicePixelRatio changed)
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        }
        window.addEventListener('resize', onResize);

        // Initial resize
        onResize();

        // Simple animation loop
        function animate() {
            requestAnimationFrame(animate);
            // rotate default chicken or auto-rotate loaded model
            if (currentModel && currentModel !== chickenGroup && autoRotateCheckbox && autoRotateCheckbox.checked) {
                currentModel.rotation.y += 0.01;
            } else if (chickenGroup) {
                chickenGroup.rotation.y += 0.01;
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Attempt to auto-load a default model from the project's /models folder.
        // Tries a couple of common names and silently continues if none are present.
        function tryAutoLoadModel() {
            const candidates = [
                'models/Chicken_skeleton_HQ.glb',
                'models/chicken.glb'
            ];
            let idx = 0;
            function tryNext() {
                if (idx >= candidates.length) return;
                const url = candidates[idx++];
                // gltfLoader.load will call the error callback if the file doesn't exist
                gltfLoader.load(url, function (gltf) {
                    try {
                        clearCurrentModel();
                        const model = gltf.scene || (gltf.scenes && gltf.scenes[0]);
                        if (!model) {
                            console.warn('GLTF had no scene:', url);
                            tryNext();
                            return;
                        }
                        fitModelToView(model);
                        scene.add(model);
                        currentModel = model;
                        const info = document.getElementById('model-info');
                        if (info) info.textContent = url.split('/').pop();
                        console.log('Auto-loaded model:', url);
                        tryApplyTexturesFor(url);
                    } catch (e) {
                        console.error('Error while auto-adding model', e);
                        tryNext();
                    }
                }, undefined, function (err) {
                    // Not found or failed to load: try next candidate
                    console.warn('Auto-load failed for', url, err && err.message ? err.message : err);
                    tryNext();
                });
            }
            tryNext();
        }

        // run auto-load once after scene is initialized
        tryAutoLoadModel();

        // Texture helper: look for common texture files for the model and apply them.
        const texLoader = new THREE.TextureLoader();

        function loadTextureIfExists(url, onLoad, onError) {
            texLoader.load(url, function (tex) {
                onLoad && onLoad(tex);
            }, undefined, function (err) {
                onError && onError(err);
            });
        }

        // Apply textures to a model by traversing meshes and setting maps.
        function applyTexturesToModel(model, baseName) {
            if (!model) return;
            const name = baseName.replace(/\.[^/.]+$/, ''); // remove extension if any
            // Try common filename variants including Unity-style "_DefaultMaterial_" suffixes
            const albedoNames = [
                `models/${name}_DefaultMaterial_AlbedoTransparency.png`,
                `models/${name}_DefaultMaterial_Albedo.png`,
                `models/${name}_DefaultMaterial_BaseColor.png`,
                `models/${name}_DefaultMaterial_BaseColorTransparency.png`,
                `models/${name}_AlbedoTransparency.png`,
                `models/${name}_albedo.png`,
                `models/${name}_BaseColor.png`,
                `models/${name}_BaseColorTransparency.png`,
                `models/${name}.png`
            ];
            const normalNames = [
                `models/${name}_DefaultMaterial_Normal.png`,
                `models/${name}_DefaultMaterial_NormalMap.png`,
                `models/${name}_Normal.png`,
                `models/${name}_normal.png`,
                `models/${name}_NormalMap.png`
            ];
            const metalNames = [
                `models/${name}_DefaultMaterial_MetallicSmoothness.png`,
                `models/${name}_DefaultMaterial_MetallicRoughness.png`,
                `models/${name}_MetallicSmoothness.png`,
                `models/${name}_metallic.png`,
                `models/${name}_metalness.png`,
                `models/${name}_metallicRoughness.png`
            ];

            // Try albedo first
            (function tryAlbedo(list) {
                let i = 0;
                function next() {
                    if (i >= list.length) { console.log('No albedo found for', name); return; }
                    const url = list[i++];
                    loadTextureIfExists(url, function (tex) {
                        tex.encoding = THREE.sRGBEncoding;
                        tex.flipY = false;
                        model.traverse(function (node) {
                            if (node.isMesh) {
                                const mats = Array.isArray(node.material) ? node.material : [node.material];
                                mats.forEach(m => {
                                    if (!m) return;
                                    // convert non-PBR to PBR-compatible if needed
                                    if (m.isMeshPhongMaterial) {
                                        // create a standard material with similar base color
                                        const std = new THREE.MeshStandardMaterial();
                                        std.copy(m);
                                        node.material = std;
                                        m = std;
                                    }
                                    if (m.map !== tex) {
                                        m.map = tex;
                                        m.needsUpdate = true;
                                    }
                                });
                            }
                        });
                        console.log('Applied albedo:', url);
                    }, function () { next(); });
                }
                next();
            })(albedoNames);

            // Try normal map
            (function tryNormal(list) {
                let i = 0;
                function next() {
                    if (i >= list.length) { console.log('No normal map found for', name); return; }
                    const url = list[i++];
                    loadTextureIfExists(url, function (tex) {
                        tex.flipY = false;
                        tex.encoding = THREE.LinearEncoding;
                        model.traverse(function (node) {
                            if (node.isMesh) {
                                const mats = Array.isArray(node.material) ? node.material : [node.material];
                                mats.forEach(m => {
                                    if (!m) return;
                                    if (m.normalMap !== tex) {
                                        m.normalMap = tex;
                                        m.normalScale = m.normalScale || new THREE.Vector2(1, 1);
                                        m.needsUpdate = true;
                                    }
                                });
                            }
                        });
                        console.log('Applied normal map:', url);
                    }, function () { next(); });
                }
                next();
            })(normalNames);

            // Try metallic / roughness (or metallic-smoothness) map
            (function tryMetal(list) {
                let i = 0;
                function next() {
                    if (i >= list.length) { console.log('No metallic/smoothness map found for', name); return; }
                    const url = list[i++];
                    loadTextureIfExists(url, function (tex) {
                        tex.flipY = false;
                        tex.encoding = THREE.LinearEncoding;

                        // Helper: convert Unity-style MetallicSmoothness (metal in R, smoothness in A) into
                        // separate metalness and roughness maps so MeshStandardMaterial can use them.
                        function convertMetallicSmoothness(tex, cb) {
                            try {
                                const img = tex.image;
                                const w = img.width || tex.image.width;
                                const h = img.height || tex.image.height;
                                const c = document.createElement('canvas');
                                c.width = w; c.height = h;
                                const ctx = c.getContext('2d');
                                ctx.drawImage(img, 0, 0, w, h);
                                const data = ctx.getImageData(0, 0, w, h).data;

                                const metalCanvas = document.createElement('canvas');
                                metalCanvas.width = w; metalCanvas.height = h;
                                const metalCtx = metalCanvas.getContext('2d');
                                const metalImg = metalCtx.createImageData(w, h);

                                const roughCanvas = document.createElement('canvas');
                                roughCanvas.width = w; roughCanvas.height = h;
                                const roughCtx = roughCanvas.getContext('2d');
                                const roughImg = roughCtx.createImageData(w, h);

                                for (let px = 0, q = 0; px < data.length; px += 4, q += 4) {
                                    const r = data[px];
                                    const g = data[px + 1];
                                    const b = data[px + 2];
                                    const a = data[px + 3];
                                    // metalness: use red channel (common for Unity exporters)
                                    const metal = r;
                                    // smoothness often stored in alpha; if alpha is 0/255 we fallback to green channel
                                    const smooth = (a !== 0 && a !== 255) ? a : g;
                                    // roughness = 255 - smoothness
                                    const rough = 255 - smooth;

                                    metalImg.data[q] = metalImg.data[q + 1] = metalImg.data[q + 2] = metal;
                                    metalImg.data[q + 3] = 255;

                                    roughImg.data[q] = roughImg.data[q + 1] = roughImg.data[q + 2] = rough;
                                    roughImg.data[q + 3] = 255;
                                }

                                metalCtx.putImageData(metalImg, 0, 0);
                                roughCtx.putImageData(roughImg, 0, 0);

                                const metalTex = new THREE.CanvasTexture(metalCanvas);
                                metalTex.encoding = THREE.LinearEncoding;
                                metalTex.flipY = false;

                                const roughTex = new THREE.CanvasTexture(roughCanvas);
                                roughTex.encoding = THREE.LinearEncoding;
                                roughTex.flipY = false;

                                cb && cb(metalTex, roughTex);
                            } catch (e) {
                                console.error('Failed to convert metallicSmoothness texture', e);
                                cb && cb(null, null);
                            }
                        }

                        // convert and apply
                        convertMetallicSmoothness(tex, function (metalTex, roughTex) {
                            model.traverse(function (node) {
                                if (node.isMesh) {
                                    const mats = Array.isArray(node.material) ? node.material : [node.material];
                                    mats.forEach(m => {
                                        if (!m) return;
                                        if (metalTex) m.metalnessMap = metalTex;
                                        if (roughTex) m.roughnessMap = roughTex;
                                        m.needsUpdate = true;
                                    });
                                }
                            });
                            console.log('Applied metallic/roughness texture (converted):', url);
                        });
                    }, function () { next(); });
                }
                next();
            })(metalNames);
        }

        // Try to auto-apply textures after auto-loading a model (derive base name from file)
        function tryApplyTexturesFor(filename) {
            if (!filename) return;
            const base = filename.split('/').pop().split('\\').pop();
            // remove extension
            const short = base.replace(/\.[^/.]+$/, '');
            // common variants: strip suffixes like _skeleton or _HQ
            const candidate = short.replace(/[_-]?(skeleton|SKEL|HQ|high|LOW)$/i, '');
            applyTexturesToModel(currentModel, short);
            // also try cleaned candidate name
            if (candidate !== short) applyTexturesToModel(currentModel, candidate);
        }
    </script>
    <script>
        // Export PDF button behavior
        const exportBtn = document.getElementById('export-pdf');
        exportBtn.addEventListener('click', () => {
            // temporarily prepare document for printing
            document.documentElement.classList.add('print-ready');
            // temporarily disable controls so they don't interfere with print
            const wasEnabled = controls.enabled;
            controls.enabled = false;

            // small delay to ensure UI stabilizes
            setTimeout(() => {
                window.print();
                // restore controls and layout after print dialog closes
                setTimeout(() => {
                    controls.enabled = wasEnabled;
                    document.documentElement.classList.remove('print-ready');
                }, 500);
            }, 150);
        });

        // Also handle beforeprint/afterprint for better compatibility
        function handleBeforePrint() { controls && (controls.enabled = false); }
        function handleAfterPrint() { controls && (controls.enabled = true); }
        if (window.matchMedia) {
            window.matchMedia('print').addListener(mql => { if (mql.matches) handleBeforePrint(); else handleAfterPrint(); });
        }
        window.addEventListener('beforeprint', handleBeforePrint);
        window.addEventListener('afterprint', handleAfterPrint);
    </script>
</body>
</html>
